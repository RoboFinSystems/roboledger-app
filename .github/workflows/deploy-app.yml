name: Deploy App

on:
  workflow_call:
    inputs:
      # GHA Runner Configuration
      runner_config:
        description: 'GitHub Actions runner configuration (JSON array)'
        required: false
        type: string
        default: '["ubuntu-latest"]'

      # Environment & AWS Configuration
      environment:
        description: 'Environment to deploy to (prod, staging, or dev)'
        required: true
        type: string
      aws_account_id:
        description: 'AWS Account ID for cross-account resources'
        required: true
        type: string
      aws_region:
        description: 'AWS region for deployment'
        required: true
        type: string
      stack_name:
        description: 'CloudFormation stack name'
        required: true
        type: string

      # Access Mode Configuration
      app_access_mode:
        description: |
          App access mode:
          - public: CloudFront + custom domain + HTTPS (requires domain)
          - public-http: CloudFront with AWS DNS, no custom domain needed
          - internal: Internal ALB only, access via bastion tunnel
        required: false
        type: string
        default: 'public'

      # S3 Bucket Configuration (passed from deploy-s3 workflow outputs)
      static_assets_bucket_name:
        description: 'S3 bucket name for static assets'
        required: true
        type: string
      static_assets_bucket_arn:
        description: 'S3 bucket ARN for static assets'
        required: true
        type: string
      static_assets_bucket_domain:
        description: 'S3 bucket regional domain name for static assets'
        required: true
        type: string

      # Container & Application Configuration
      ecr_repository:
        description: 'ECR repository name'
        required: true
        type: string
      ecr_image_tag:
        description: 'Docker image tag'
        required: true
        type: string

      # ECS & Compute Configuration
      cpu:
        description: 'CPU units for ECS task (256 = 0.25 vCPU)'
        required: false
        type: string
        default: '256'
      memory:
        description: 'Memory in MiB for ECS task'
        required: false
        type: string
        default: '512'
      fargate_weight:
        description: 'Weight for FARGATE capacity provider (On-Demand instances)'
        required: false
        type: string
        default: '20'
      fargate_spot_weight:
        description: 'Weight for FARGATE_SPOT capacity provider (Spot instances)'
        required: false
        type: string
        default: '80'

      # Auto-scaling Configuration
      capacity_min:
        description: 'Minimum number of tasks for auto scaling'
        required: false
        type: string
        default: '1'
      capacity_max:
        description: 'Maximum number of tasks for auto scaling'
        required: false
        type: string
        default: '10'
      scale_up_cpu_threshold:
        description: 'CPU utilization percentage to trigger scale up'
        required: false
        type: string
        default: '70'
      scale_down_cpu_threshold:
        description: 'CPU utilization percentage to trigger scale down'
        required: false
        type: string
        default: '30'
      scale_up_memory_threshold:
        description: 'Memory utilization percentage to trigger scale up'
        required: false
        type: string
        default: '65'
      scale_down_memory_threshold:
        description: 'Memory utilization percentage to trigger scale down'
        required: false
        type: string
        default: '25'

      # Domain & DNS Configuration (required only when app_access_mode=public)
      domain_name:
        description: 'Full domain name for the application (e.g., roboledger.ai). Required for public mode.'
        required: false
        type: string
        default: ''
      domain_name_root:
        description: 'Root domain name for Route 53 hosted zone. Required for public mode.'
        required: false
        type: string
        default: ''

      # SNS Configuration
      notification_email:
        description: 'Email address for admin notifications (contact form)'
        required: true
        type: string

    secrets:
      ACTIONS_TOKEN:
        required: true

jobs:
  action:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.REPOSITORY_NAME || 'RoboFinSystems/roboledger-app' }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Get VPC Stack Information
        id: get-vpc-info
        run: |
          # Use the shared VPC stack for both environments
          STACK_NAME="RoboSystemsVPC"

          echo "Looking up CloudFormation stack: $STACK_NAME"

          # Check if stack exists
          if ! aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
            echo "Error: Stack $STACK_NAME not found"
            exit 1
          fi

          # Get VPC ID
          VPC_ID=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue | [0]" \
            --output text)

          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "Found VPC ID: $VPC_ID"

          # Get Public Subnet IDs
          PUBLIC_SUBNET_IDS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='PublicSubnetIds'].OutputValue | [0]" \
            --output text)

          echo "public_subnet_ids=$PUBLIC_SUBNET_IDS" >> $GITHUB_OUTPUT
          echo "Found Public Subnet IDs: $PUBLIC_SUBNET_IDS"

          # Get Private Subnet IDs
          PRIVATE_SUBNET_IDS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='PrivateSubnetIds'].OutputValue | [0]" \
            --output text)

          echo "private_subnet_ids=$PRIVATE_SUBNET_IDS" >> $GITHUB_OUTPUT
          echo "Found Private Subnet IDs: $PRIVATE_SUBNET_IDS"

          # Get NAT Gateway IP
          NAT_GATEWAY_IP=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='NatGatewayIPs'].OutputValue | [0]" \
            --output text)

          echo "nat_gateway_ips=$NAT_GATEWAY_IP" >> $GITHUB_OUTPUT
          echo "Found NAT Gateway IP: $NAT_GATEWAY_IP"

          echo "Summary of network resources:"
          echo "  VPC ID: $VPC_ID"
          echo "  Public Subnets: $PUBLIC_SUBNET_IDS"
          echo "  Private Subnets: $PRIVATE_SUBNET_IDS"
          echo "  NAT Gateway IP: $NAT_GATEWAY_IP"

      - name: Get Secret ARNs
        id: get-arns
        run: |
          # Get RoboSystems secrets ARN (shared across all RoboFin apps)
          ROBOSYSTEMS_SECRETS_ARN=$(aws secretsmanager describe-secret \
            --secret-id "robosystems/${{ inputs.environment }}" \
            --query "ARN" --output text)

          echo "robosystems_secrets_arn=$ROBOSYSTEMS_SECRETS_ARN" >> $GITHUB_OUTPUT
          echo "Found RoboSystems secret ARN: $ROBOSYSTEMS_SECRETS_ARN"

      - name: Deploy RoboLedger CloudFormation Stack
        id: deploy-stack
        run: |
          # Look up hosted zone ID only for public mode (requires custom domain)
          HOSTED_ZONE_ID=""
          if [ "${{ inputs.app_access_mode }}" = "public" ]; then
            if [ -z "${{ inputs.domain_name_root }}" ]; then
              echo "ERROR: domain_name_root is required for public access mode"
              exit 1
            fi
            HOSTED_ZONE_ID=$(aws route53 list-hosted-zones | jq -r ".HostedZones[] | select(.Name==\"${{ inputs.domain_name_root }}.\") | .Id" | cut -d'/' -f3)
            if [ -z "$HOSTED_ZONE_ID" ]; then
              echo "ERROR: No hosted zone found for domain ${{ inputs.domain_name_root }}"
              exit 1
            fi
            echo "Found hosted zone ID: $HOSTED_ZONE_ID for domain ${{ inputs.domain_name_root }}"
          else
            echo "Skipping hosted zone lookup for ${{ inputs.app_access_mode }} mode"
          fi

          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} 2>&1 | grep -q 'Stack with id ${{ inputs.stack_name }} does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new stack ${{ inputs.stack_name }}"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "Updating existing stack ${{ inputs.stack_name }}"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Base parameters (always required)
          APP_STACK_PARAMS="ParameterKey=Environment,ParameterValue=${{ inputs.environment }} \
                ParameterKey=AWSAccountId,ParameterValue=${{ inputs.aws_account_id }} \
                ParameterKey=AppAccessMode,ParameterValue=${{ inputs.app_access_mode }} \
                ParameterKey=RoboLedgerSecretsArn,ParameterValue=${{ steps.get-arns.outputs.robosystems_secrets_arn }} \
                ParameterKey=VpcId,ParameterValue=${{ steps.get-vpc-info.outputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue=\"${{ steps.get-vpc-info.outputs.private_subnet_ids }}\" \
                ParameterKey=PublicSubnetIds,ParameterValue=\"${{ steps.get-vpc-info.outputs.public_subnet_ids }}\" \
                ParameterKey=ECRRepository,ParameterValue=${{ inputs.ecr_repository }} \
                ParameterKey=ECRImageTag,ParameterValue=${{ inputs.ecr_image_tag }} \
                ParameterKey=Cpu,ParameterValue=${{ inputs.cpu }} \
                ParameterKey=Memory,ParameterValue=${{ inputs.memory }} \
                ParameterKey=StaticAssetsBucketName,ParameterValue=${{ inputs.static_assets_bucket_name }} \
                ParameterKey=StaticAssetsBucketArn,ParameterValue=${{ inputs.static_assets_bucket_arn }} \
                ParameterKey=StaticAssetsBucketDomainName,ParameterValue=${{ inputs.static_assets_bucket_domain }} \
                ParameterKey=CapacityMin,ParameterValue=${{ inputs.capacity_min }} \
                ParameterKey=CapacityMax,ParameterValue=${{ inputs.capacity_max }} \
                ParameterKey=ScaleUpCPUThreshold,ParameterValue=${{ inputs.scale_up_cpu_threshold }} \
                ParameterKey=ScaleDownCPUThreshold,ParameterValue=${{ inputs.scale_down_cpu_threshold }} \
                ParameterKey=ScaleUpMemoryThreshold,ParameterValue=${{ inputs.scale_up_memory_threshold }} \
                ParameterKey=ScaleDownMemoryThreshold,ParameterValue=${{ inputs.scale_down_memory_threshold }} \
                ParameterKey=FargateSpotWeight,ParameterValue=${{ inputs.fargate_spot_weight }} \
                ParameterKey=FargateWeight,ParameterValue=${{ inputs.fargate_weight }} \
                ParameterKey=NotificationEmail,ParameterValue=${{ inputs.notification_email }}"

          # Add domain parameters only for public mode
          if [ "${{ inputs.app_access_mode }}" = "public" ]; then
            APP_STACK_PARAMS="$APP_STACK_PARAMS \
                ParameterKey=DomainName,ParameterValue=${{ inputs.domain_name }} \
                ParameterKey=HostedZoneId,ParameterValue=$HOSTED_ZONE_ID"
          fi

          # Deploy or update the stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            # Create new stack
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/template.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters $APP_STACK_PARAMS
          else
            # Update existing stack, handling "No updates" error
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/template.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters $APP_STACK_PARAMS 2>&1) || true

            # Check if the error was "No updates are to be performed"
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "Stack is already up to date - no changes needed"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            elif echo "$UPDATE_OUTPUT" | grep -q "error"; then
              echo "Error updating stack: $UPDATE_OUTPUT"
              exit 1
            else
              echo "Stack update initiated successfully"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: ${{ inputs.stack_name }}
          timeout: '1800'
          interval: '10'

      - name: Refresh ECS Service
        if: steps.deploy-stack.outputs.is_new_stack == 'false'
        uses: ./.github/actions/refresh-ecs
        with:
          stack-name: ${{ inputs.stack_name }}
          skip-autoscale-refresh: 'false'
          max-wait-time: '600'
          service-stability-delay: '30'

      - name: Update Deployment Status
        if: always()
        run: |
          # Output deployment status for the main workflow
          if [ "${{ steps.deploy-stack.outputs.is_new_stack }}" == "true" ]; then
            echo "RoboLedger app stack creation completed"
          else
            echo "RoboLedger app stack update completed"
          fi
