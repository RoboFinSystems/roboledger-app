name: Deploy App

on:
  workflow_call:
    inputs:
      # GHA Runner Configuration
      runner_config:
        description: 'GitHub Actions runner configuration (JSON array)'
        required: false
        type: string
        default: '["ubuntu-latest"]'

      # Environment & AWS Configuration
      environment:
        description: 'Environment to deploy to (prod, staging, or dev)'
        required: true
        type: string
      aws_account_id:
        description: 'AWS Account ID for cross-account resources'
        required: true
        type: string
      aws_region:
        description: 'AWS region for deployment'
        required: true
        type: string
      stack_name:
        description: 'CloudFormation stack name'
        required: true
        type: string

      # Access Mode Configuration
      app_access_mode:
        description: |
          App access mode:
          - public: CloudFront + custom domain + HTTPS (requires domain)
          - public-http: CloudFront with AWS DNS, no custom domain needed
        required: false
        type: string
        default: 'public'

      # S3 Bucket Configuration (passed from deploy-s3 workflow outputs)
      static_assets_bucket_name:
        description: 'S3 bucket name for static assets'
        required: true
        type: string
      static_assets_bucket_arn:
        description: 'S3 bucket ARN for static assets'
        required: true
        type: string
      static_assets_bucket_domain:
        description: 'S3 bucket regional domain name for static assets'
        required: true
        type: string

      # Container & Application Configuration
      ecr_repository:
        description: 'ECR repository name'
        required: true
        type: string
      ecr_image_tag:
        description: 'Docker image tag'
        required: true
        type: string

      # App Runner Compute Configuration
      cpu:
        description: 'CPU for App Runner instance'
        required: false
        type: string
        default: '0.25 vCPU'
      memory:
        description: 'Memory for App Runner instance'
        required: false
        type: string
        default: '0.5 GB'

      # Auto-scaling Configuration
      capacity_min:
        description: 'Minimum number of instances for auto scaling'
        required: false
        type: string
        default: '1'
      capacity_max:
        description: 'Maximum number of instances for auto scaling'
        required: false
        type: string
        default: '10'
      max_concurrency:
        description: 'Maximum concurrent requests per instance before scaling'
        required: false
        type: string
        default: '100'

      # Domain & DNS Configuration (required only when app_access_mode=public)
      domain_name:
        description: 'Full domain name for the application (e.g., roboledger.ai). Required for public mode.'
        required: false
        type: string
        default: ''
      domain_name_root:
        description: 'Root domain name for Route 53 hosted zone. Required for public mode.'
        required: false
        type: string
        default: ''

      # SNS Configuration
      notification_email:
        description: 'Email address for admin notifications (contact form)'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ github.token }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Get Secret ARNs
        id: get-arns
        run: |
          # Get main RoboSystems secrets ARN
          ROBOSYSTEMS_SECRETS_ARN=$(aws secretsmanager describe-secret \
            --secret-id "robosystems/${{ inputs.environment }}" \
            --query "ARN" --output text)

          echo "robosystems_secrets_arn=$ROBOSYSTEMS_SECRETS_ARN" >> $GITHUB_OUTPUT
          echo "Found RoboSystems secret ARN: $ROBOSYSTEMS_SECRETS_ARN"

      - name: Deploy RoboLedger CloudFormation Stack
        id: deploy-stack
        run: |
          # Look up hosted zone ID only for public mode (requires custom domain)
          HOSTED_ZONE_ID=""
          if [ "${{ inputs.app_access_mode }}" = "public" ]; then
            if [ -z "${{ inputs.domain_name_root }}" ]; then
              echo "ERROR: domain_name_root is required for public access mode"
              exit 1
            fi
            HOSTED_ZONE_ID=$(aws route53 list-hosted-zones | jq -r ".HostedZones[] | select(.Name==\"${{ inputs.domain_name_root }}.\") | .Id" | cut -d'/' -f3)
            if [ -z "$HOSTED_ZONE_ID" ]; then
              echo "ERROR: No hosted zone found for domain ${{ inputs.domain_name_root }}"
              exit 1
            fi
            echo "Found hosted zone ID: $HOSTED_ZONE_ID for domain ${{ inputs.domain_name_root }}"
          else
            echo "Skipping hosted zone lookup for ${{ inputs.app_access_mode }} mode"
          fi

          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} 2>&1 | grep -q 'Stack with id ${{ inputs.stack_name }} does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new stack ${{ inputs.stack_name }}"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "Updating existing stack ${{ inputs.stack_name }}"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Build parameters JSON file (handles spaces in values correctly)
          cat > /tmp/cfn-params.json << 'PARAMS_EOF'
          [
            {"ParameterKey": "Environment", "ParameterValue": "${{ inputs.environment }}"},
            {"ParameterKey": "AWSAccountId", "ParameterValue": "${{ inputs.aws_account_id }}"},
            {"ParameterKey": "AppAccessMode", "ParameterValue": "${{ inputs.app_access_mode }}"},
            {"ParameterKey": "RoboSystemsSecretsArn", "ParameterValue": "${{ steps.get-arns.outputs.robosystems_secrets_arn }}"},
            {"ParameterKey": "ECRRepository", "ParameterValue": "${{ inputs.ecr_repository }}"},
            {"ParameterKey": "ECRImageTag", "ParameterValue": "${{ inputs.ecr_image_tag }}"},
            {"ParameterKey": "Cpu", "ParameterValue": "${{ inputs.cpu }}"},
            {"ParameterKey": "Memory", "ParameterValue": "${{ inputs.memory }}"},
            {"ParameterKey": "StaticAssetsBucketName", "ParameterValue": "${{ inputs.static_assets_bucket_name }}"},
            {"ParameterKey": "StaticAssetsBucketArn", "ParameterValue": "${{ inputs.static_assets_bucket_arn }}"},
            {"ParameterKey": "StaticAssetsBucketDomainName", "ParameterValue": "${{ inputs.static_assets_bucket_domain }}"},
            {"ParameterKey": "CapacityMin", "ParameterValue": "${{ inputs.capacity_min }}"},
            {"ParameterKey": "CapacityMax", "ParameterValue": "${{ inputs.capacity_max }}"},
            {"ParameterKey": "MaxConcurrency", "ParameterValue": "${{ inputs.max_concurrency }}"},
            {"ParameterKey": "NotificationEmail", "ParameterValue": "${{ inputs.notification_email }}"}
          ]
          PARAMS_EOF

          # Add domain parameters only for public mode
          if [ "${{ inputs.app_access_mode }}" = "public" ]; then
            sed -i '$ d' /tmp/cfn-params.json
            cat >> /tmp/cfn-params.json << DOMAIN_EOF
            ,{"ParameterKey": "DomainName", "ParameterValue": "${{ inputs.domain_name }}"},
            {"ParameterKey": "HostedZoneId", "ParameterValue": "$HOSTED_ZONE_ID"}
          ]
          DOMAIN_EOF
          fi

          echo "Parameters:"
          cat /tmp/cfn-params.json

          # Deploy or update the stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            # Create new stack
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/template.yaml \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameters file:///tmp/cfn-params.json
          else
            # Update existing stack, handling "No updates" error
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/template.yaml \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameters file:///tmp/cfn-params.json 2>&1) || true

            # Check if the error was "No updates are to be performed"
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "Stack is already up to date - no changes needed"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            elif echo "$UPDATE_OUTPUT" | grep -q "error"; then
              echo "Error updating stack: $UPDATE_OUTPUT"
              exit 1
            else
              echo "Stack update initiated successfully"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: ${{ inputs.stack_name }}
          timeout: '1800'
          interval: '10'

      - name: Get App Runner Service Info
        id: get-service-info
        run: |
          # Get the App Runner service ARN from stack outputs
          SERVICE_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack_name }} \
            --query "Stacks[0].Outputs[?OutputKey=='AppRunnerServiceArn'].OutputValue" \
            --output text)

          echo "service_arn=$SERVICE_ARN" >> $GITHUB_OUTPUT
          echo "App Runner Service ARN: $SERVICE_ARN"

          # Get the service URL
          SERVICE_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack_name }} \
            --query "Stacks[0].Outputs[?OutputKey=='AppRunnerServiceUrl'].OutputValue" \
            --output text)

          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "App Runner Service URL: $SERVICE_URL"

      - name: Wait for App Runner Deployment
        run: |
          SERVICE_ARN="${{ steps.get-service-info.outputs.service_arn }}"
          MAX_ATTEMPTS=60
          SLEEP_INTERVAL=10

          echo "Waiting for App Runner service to become ready..."

          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(aws apprunner describe-service \
              --service-arn "$SERVICE_ARN" \
              --query "Service.Status" \
              --output text)

            echo "Attempt $i/$MAX_ATTEMPTS: Service status is $STATUS"

            if [ "$STATUS" = "RUNNING" ]; then
              echo "App Runner service is running!"
              break
            elif [ "$STATUS" = "CREATE_FAILED" ] || [ "$STATUS" = "DELETE_FAILED" ] || [ "$STATUS" = "UPDATE_FAILED" ]; then
              echo "ERROR: App Runner service deployment failed with status: $STATUS"
              exit 1
            fi

            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "ERROR: Timeout waiting for App Runner service to become ready"
              exit 1
            fi

            sleep $SLEEP_INTERVAL
          done

      - name: Verify Health Check
        run: |
          SERVICE_URL="${{ steps.get-service-info.outputs.service_url }}"
          HEALTH_URL="https://${SERVICE_URL}/api/utilities/health"

          echo "Checking health endpoint: $HEALTH_URL"

          # Wait for health check to pass
          MAX_ATTEMPTS=12
          for i in $(seq 1 $MAX_ATTEMPTS); do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Health check passed! HTTP $HTTP_STATUS"
              break
            fi

            echo "Attempt $i/$MAX_ATTEMPTS: Health check returned HTTP $HTTP_STATUS"

            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "ERROR: Health check did not return 200 after $MAX_ATTEMPTS attempts"
              exit 1
            fi

            sleep 10
          done

      - name: Update Deployment Status
        if: always()
        run: |
          if [ "${{ steps.deploy-stack.outputs.is_new_stack }}" == "true" ]; then
            echo "RoboLedger app stack creation completed"
          else
            echo "RoboLedger app stack update completed"
          fi

          echo ""
          echo "App Runner Service URL: ${{ steps.get-service-info.outputs.service_url }}"
