name: Build

on:
  workflow_call:
    inputs:
      runner_config:
        required: false
        type: string
        description: 'Runner configuration JSON (from runner availability check)'
        default: '["ubuntu-latest"]'
      environment:
        required: true
        type: string
      region:
        required: true
        type: string
        default: 'us-east-1'
      robosystems_api_url:
        required: true
        type: string
      roboledger_app_url:
        required: true
        type: string
      roboinvestor_app_url:
        required: true
        type: string
      robosystems_app_url:
        required: true
        type: string
      maintenance_mode:
        required: false
        type: string
        default: 'false'
      turnstile_site_key:
        required: false
        type: string
        default: ''
      publish_to_dockerhub:
        required: false
        type: boolean
        default: false
        description: 'Whether to publish images to Docker Hub'
    outputs:
      image:
        description: 'Built image reference'
        value: ${{ jobs.ecr-build.outputs.image }}
      ecr_repository_url:
        description: 'ECR repository URL'
        value: ${{ jobs.ecr-build.outputs.ecr_repository_url }}
      version_tag:
        description: 'Version tag used for the build'
        value: ${{ jobs.ecr-build.outputs.version_tag }}
      is_release:
        description: 'Whether this is a release build'
        value: ${{ jobs.ecr-build.outputs.is_release }}
    secrets:
      ACTIONS_TOKEN:
        required: true
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false

jobs:
  # ===========================================================================
  # ECR Build - Production/Staging deployments with baked-in environment values
  # ===========================================================================
  ecr-build:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    outputs:
      image: ${{ steps.build-and-push.outputs.image }}
      ecr_repository_url: ${{ steps.build-and-push.outputs.ecr_repository_url }}
      version_tag: ${{ steps.build-and-push.outputs.version_tag }}
      is_release: ${{ steps.build-and-push.outputs.is_release }}
    steps:
      - name: Free disk space
        run: |
          echo "Disk space before cleanup:"
          df -h /
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          echo "Disk space after cleanup:"
          df -h /

      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.REPOSITORY_NAME || 'RoboFinSystems/roboledger-app' }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:master
            network=host

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies and build Next.js
        env:
          NEXT_PUBLIC_ROBOSYSTEMS_API_URL: ${{ inputs.robosystems_api_url }}
          NEXT_PUBLIC_ROBOLEDGER_APP_URL: ${{ inputs.roboledger_app_url }}
          NEXT_PUBLIC_ROBOINVESTOR_APP_URL: ${{ inputs.roboinvestor_app_url }}
          NEXT_PUBLIC_ROBOSYSTEMS_APP_URL: ${{ inputs.robosystems_app_url }}
          NEXT_PUBLIC_MAINTENANCE_MODE: ${{ inputs.maintenance_mode }}
          NEXT_PUBLIC_TURNSTILE_SITE_KEY: ${{ inputs.turnstile_site_key }}
        run: |
          npm ci
          npm run build

          # Create a tarball of the build output for Docker to use
          tar -czf next-build.tar.gz .next

      - name: Sync static assets to S3
        env:
          S3_BUCKET: roboledger-app-${{ inputs.environment }}-static-assets
        run: |
          # Check if S3 bucket exists
          if aws s3api head-bucket --bucket "$S3_BUCKET" 2>/dev/null; then
            echo "S3 bucket exists, syncing static assets..."

            # Sync public folder (images, etc)
            echo "Syncing public folder..."
            aws s3 sync ./public s3://$S3_BUCKET/ \
              --cache-control "public, max-age=31536000, immutable" \
              --exclude ".git/*" \
              --exclude "node_modules/*"

            # Sync Next.js static build output
            echo "Syncing Next.js static files..."
            aws s3 sync ./.next/static s3://$S3_BUCKET/_next/static/ \
              --cache-control "public, max-age=31536000, immutable"

            # Get stack name based on environment
            if [ "${{ inputs.environment }}" == "prod" ]; then
              STACK_NAME="RoboLedgerAppProd"
            else
              STACK_NAME="RoboLedgerAppStaging"
            fi

            # Check if the main application stack exists
            if aws cloudformation describe-stacks --stack-name $STACK_NAME >/dev/null 2>&1; then
              echo "Stack $STACK_NAME exists, looking up CloudFront distribution ID..."

              # Try to get CloudFront distribution ID from CloudFormation stack outputs
              CLOUDFRONT_DISTRIBUTION_ID=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='CloudFrontDistributionId'].OutputValue" --output text 2>/dev/null)

              # Invalidate CloudFront cache if we found the distribution ID
              if [ -n "$CLOUDFRONT_DISTRIBUTION_ID" ] && [ "$CLOUDFRONT_DISTRIBUTION_ID" != "None" ]; then
                echo "Found CloudFront distribution ID: $CLOUDFRONT_DISTRIBUTION_ID"
                echo "Invalidating CloudFront cache..."
                aws cloudfront create-invalidation \
                  --distribution-id $CLOUDFRONT_DISTRIBUTION_ID \
                  --paths "/*"
              else
                echo "CloudFront distribution ID not found in stack outputs."
                echo "Continuing without cache invalidation."
              fi
            else
              echo "Stack $STACK_NAME does not exist yet."
              echo "This is expected for first-time deployments."
              echo "CloudFront cache invalidation will be skipped."
            fi
          else
            echo "S3 bucket doesn't exist yet. Skipping static asset sync."
            echo "Please deploy the CloudFormation stack first to create the bucket."
          fi

      - name: Build, tag, and push Docker image to ECR
        id: build-and-push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        run: |
          export DOCKER_BUILDKIT=1
          export COMPOSE_DOCKER_CLI_BUILD=1

          # Determine version information
          VERSION_TAG=""
          IS_RELEASE="false"

          # Check if this is a version tag (v*.*.*)
          if [[ "$GITHUB_REF" == refs/tags/v*.*.* ]]; then
            VERSION_TAG=${GITHUB_REF#refs/tags/}
            IS_RELEASE="true"
            echo "üì¶ Building release version: $VERSION_TAG"
          # Check if this is a release branch (release/*)
          elif [[ "$GITHUB_REF" == refs/heads/release/* ]]; then
            # Extract version from branch name (e.g., release/1.0.0 -> v1.0.0)
            BRANCH_VERSION=${GITHUB_REF#refs/heads/release/}
            VERSION_TAG="v${BRANCH_VERSION}-hotfix.${GITHUB_SHA:0:8}"
            IS_RELEASE="true"
            echo "üî• Building hotfix version: $VERSION_TAG (from release/$BRANCH_VERSION)"
          else
            # For non-release builds, use commit SHA
            VERSION_TAG="git-${GITHUB_SHA:0:8}"
            echo "üîß Building development version: $VERSION_TAG"
          fi

          # Prepare ECR tags
          TAGS="-t $ECR_REGISTRY/$ECR_REPOSITORY:${{ inputs.environment }}"
          TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG"

          if [[ "${{ inputs.environment }}" == "prod" ]]; then
            TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:latest"
          fi

          # Build and push to ECR (amd64 only for ECS/Fargate)
          docker buildx build \
            --platform linux/amd64 \
            --push \
            --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache \
            --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:deps-cache \
            --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache,mode=max \
            --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:deps-cache,mode=max \
            $TAGS \
            -f Dockerfile .

          # Verify the image was pushed successfully to ECR
          aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=${{ inputs.environment }} || exit 1
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$ECR_REGISTRY/$ECR_REPOSITORY" >> $GITHUB_OUTPUT
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          # Log the tags that were created
          echo "üìã ECR image tags created:"
          echo "$TAGS" | tr ' ' '\n' | grep -E '^-t' | sed 's/-t /  - /'

  # ===========================================================================
  # Docker Hub Build - Configurable image with runtime environment injection
  # ===========================================================================
  # This job builds a separate image with placeholder values that get replaced
  # at container startup via entrypoint.sh. This allows users to configure
  # the image for any environment (local dev, self-hosted, etc.)
  # ===========================================================================
  dockerhub-build:
    if: ${{ inputs.publish_to_dockerhub == true }}
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 25
    permissions:
      contents: read
    steps:
      - name: Free disk space
        run: |
          echo "Disk space before cleanup:"
          df -h /
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          echo "Disk space after cleanup:"
          df -h /

      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ vars.REPOSITORY_NAME || 'RoboFinSystems/roboledger-app' }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:master
            network=host

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies and build Next.js with placeholders
        env:
          # Use placeholder values that will be replaced at runtime by entrypoint.sh
          NEXT_PUBLIC_ROBOSYSTEMS_API_URL: '__PLACEHOLDER_ROBOSYSTEMS_API_URL__'
          NEXT_PUBLIC_ROBOLEDGER_APP_URL: '__PLACEHOLDER_ROBOLEDGER_APP_URL__'
          NEXT_PUBLIC_ROBOINVESTOR_APP_URL: '__PLACEHOLDER_ROBOINVESTOR_APP_URL__'
          NEXT_PUBLIC_ROBOSYSTEMS_APP_URL: '__PLACEHOLDER_ROBOSYSTEMS_APP_URL__'
          NEXT_PUBLIC_MAINTENANCE_MODE: '__PLACEHOLDER_MAINTENANCE_MODE__'
          NEXT_PUBLIC_TURNSTILE_SITE_KEY: '__PLACEHOLDER_TURNSTILE_SITE_KEY__'
          NEXT_PUBLIC_S3_ENDPOINT_URL: '__PLACEHOLDER_S3_ENDPOINT_URL__'
        run: |
          npm ci
          npm run build

          # Create a tarball of the build output for Docker to use
          tar -czf next-build.tar.gz .next

      - name: Determine version tag
        id: version
        run: |
          VERSION_TAG=""
          IS_RELEASE="false"

          # Check if this is a version tag (v*.*.*)
          if [[ "$GITHUB_REF" == refs/tags/v*.*.* ]]; then
            VERSION_TAG=${GITHUB_REF#refs/tags/}
            IS_RELEASE="true"
            echo "üì¶ Release version: $VERSION_TAG"
          # Check if this is a release branch (release/*)
          elif [[ "$GITHUB_REF" == refs/heads/release/* ]]; then
            BRANCH_VERSION=${GITHUB_REF#refs/heads/release/}
            VERSION_TAG="v${BRANCH_VERSION}-hotfix.${GITHUB_SHA:0:8}"
            IS_RELEASE="true"
            echo "üî• Hotfix version: $VERSION_TAG"
          else
            VERSION_TAG="git-${GITHUB_SHA:0:8}"
            echo "üîß Development version: $VERSION_TAG"
          fi

          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

      - name: Build and push to Docker Hub
        if: steps.version.outputs.is_release == 'true'
        run: |
          export DOCKER_BUILDKIT=1
          export COMPOSE_DOCKER_CLI_BUILD=1

          VERSION_TAG="${{ steps.version.outputs.version_tag }}"

          # Prepare Docker Hub tags
          TAGS="-t robofinsystems/roboledger-app:latest"
          TAGS="$TAGS -t robofinsystems/roboledger-app:$VERSION_TAG"

          echo "üöÄ Publishing configurable image to Docker Hub"

          # Build for both amd64 and arm64 (for Mac M1/M2 users)
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --push \
            $TAGS \
            -f Dockerfile .

          echo "üìã Docker Hub image tags created:"
          echo "$TAGS" | tr ' ' '\n' | grep -E '^-t' | sed 's/-t /  - /'

      - name: Skip non-release build
        if: steps.version.outputs.is_release != 'true'
        run: |
          echo "‚è≠Ô∏è Skipping Docker Hub publication (non-release build)"
          echo "Docker Hub images are only published for version tags (v*.*.*) and release branches"
